.TH "lib/esd/ess_socket.h" 3 "Sun Feb 3 2019" "Version 0.3" "OpenESS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/esd/ess_socket.h
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBess_socket\fP"
.br
.RI "hold all socket managment importend data "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBess_socket_fam\fP \fBess_socket_fam_t\fP"
.br
.RI "which ip family are use "
.ti -1c
.RI "typedef enum \fBess_socket_pro\fP \fBess_socket_pro_t\fP"
.br
.RI "which comunications protocol are use "
.ti -1c
.RI "typedef enum \fBess_socket_status\fP \fBess_socket_status_t\fP"
.br
.RI "\fBess_socket\fP status "
.ti -1c
.RI "typedef enum \fBess_socket_error\fP \fBess_socket_error_t\fP"
.br
.RI "\fBess_socket\fP error "
.ti -1c
.RI "typedef struct \fBess_socket\fP \fBess_socket_t\fP"
.br
.RI "hold all socket managment importend data "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBess_socket_fam\fP { \fBESS_SOCKET_FAMILY_IP4\fP, \fBESS_SOCKET_FAMILY_IP6\fP, \fBESS_SOCKET_FAMILY_BOTH\fP }
.RI "which ip family are use ""
.br
.ti -1c
.RI "enum \fBess_socket_pro\fP { \fBESS_SOCKET_PROTO_DRAM\fP, \fBESS_SOCKET_PROTO_STREAM\fP, \fBESS_SOCKET_PROTO_DRAM_LITE\fP }
.RI "which comunications protocol are use ""
.br
.ti -1c
.RI "enum \fBess_socket_status\fP { \fBESS_SOCKET_STATUS_CREATED\fP, \fBESS_SOCKET_STATUS_LISTEN\fP, \fBESS_SOCKET_STATUS_STOPPED\fP, \fBESS_SOCKET_STATUS_ERROR\fP, \fBESS_SOCKET_STATUS_DESTROY\fP }
.RI "\fBess_socket\fP status ""
.br
.ti -1c
.RI "enum \fBess_socket_error\fP { \fBESS_SOCKET_ERROR_OK\fP = 0, \fBESS_SOCKET_ERROR_NULL\fP = -1, \fBESS_SOCKET_ERROR_UNSPEC_PROTOKOL\fP, \fBESS_SOCKET_ERROR_UNSPEC_FAMILY\fP, \fBESS_SOCKET_ERROR_UNSPEC\fP, \fBESS_SOCKET_ERROR_GETADDR\fP, \fBESS_SOCKET_ERROR_BIND\fP, \fBESS_SOCKET_ERROR_CLOSE\fP }
.RI "\fBess_socket\fP error ""
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBess_socket_fam_t\fP \fBess_get_address_family\fP (const char *hostname)"
.br
.RI "Look up which address families a host supports\&. "
.ti -1c
.RI "\fBess_socket_error_t\fP \fBess_socket_create\fP (\fBess_socket_t\fP *socket, \fBess_socket_fam_t\fP fam, \fBess_socket_pro_t\fP protokoll, const char *addr, unsigned short port)"
.br
.RI "setup the \fBess_socket\fP structure "
.ti -1c
.RI "\fBess_socket_error_t\fP \fBess_socket_create_server\fP (\fBess_socket_t\fP *socket)"
.br
.RI "Create a TCP or UDP server socket\&. "
.ti -1c
.RI "\fBess_socket_error_t\fP \fBess_socket_close\fP (\fBess_socket_t\fP *socket)"
.br
.RI "Close a socket\&. "
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBess_socket_error\fP \fBess_socket_error_t\fP"

.PP
\fBess_socket\fP error 
.SS "typedef enum \fBess_socket_fam\fP \fBess_socket_fam_t\fP"

.PP
which ip family are use 
.SS "typedef enum \fBess_socket_pro\fP \fBess_socket_pro_t\fP"

.PP
which comunications protocol are use 
.SS "typedef enum \fBess_socket_status\fP \fBess_socket_status_t\fP"

.PP
\fBess_socket\fP status 
.SS "typedef struct \fBess_socket\fP \fBess_socket_t\fP"

.PP
hold all socket managment importend data 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBess_socket_error\fP"

.PP
\fBess_socket\fP error 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIESS_SOCKET_ERROR_OK \fP\fP
no error 
.TP
\fB\fIESS_SOCKET_ERROR_NULL \fP\fP
\fCess_socket_t\fP is NULL 
.TP
\fB\fIESS_SOCKET_ERROR_UNSPEC_PROTOKOL \fP\fP
unknown protokol 
.TP
\fB\fIESS_SOCKET_ERROR_UNSPEC_FAMILY \fP\fP
unknown family 
.TP
\fB\fIESS_SOCKET_ERROR_UNSPEC \fP\fP
.TP
\fB\fIESS_SOCKET_ERROR_GETADDR \fP\fP
getaddrinfo error see \fBess_socket_t::retval\fP 
.TP
\fB\fIESS_SOCKET_ERROR_BIND \fP\fP
bind error see \fBess_socket_t::retval\fP 
.TP
\fB\fIESS_SOCKET_ERROR_CLOSE \fP\fP
close error see \fBess_socket_t::retval\fP 
.SS "enum \fBess_socket_fam\fP"

.PP
which ip family are use 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIESS_SOCKET_FAMILY_IP4 \fP\fP
Internet protocol version 4 
.TP
\fB\fIESS_SOCKET_FAMILY_IP6 \fP\fP
Internet protocol version 6 
.TP
\fB\fIESS_SOCKET_FAMILY_BOTH \fP\fP
Unspec DNS resolver should decide\&. 
.SS "enum \fBess_socket_pro\fP"

.PP
which comunications protocol are use 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIESS_SOCKET_PROTO_DRAM \fP\fP
UDP 
.TP
\fB\fIESS_SOCKET_PROTO_STREAM \fP\fP
TCP 
.TP
\fB\fIESS_SOCKET_PROTO_DRAM_LITE \fP\fP
UDP Lite 
.SS "enum \fBess_socket_status\fP"

.PP
\fBess_socket\fP status 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIESS_SOCKET_STATUS_CREATED \fP\fP
Socket is created and ready for using 
.TP
\fB\fIESS_SOCKET_STATUS_LISTEN \fP\fP
server is running 
.TP
\fB\fIESS_SOCKET_STATUS_STOPPED \fP\fP
socket is close 
.TP
\fB\fIESS_SOCKET_STATUS_ERROR \fP\fP
socket has an error 
.TP
\fB\fIESS_SOCKET_STATUS_DESTROY \fP\fP
socket is destroyed 
.SH "Function Documentation"
.PP 
.SS "\fBess_socket_fam_t\fP ess_get_address_family (const char * hostname)"

.PP
Look up which address families a host supports\&. If you want to send a datagram to a host but you don't know if it supports IPv4 or IPv6, use this function\&.
.PP
\fBParameters:\fP
.RS 4
\fIhostname\fP The hostname of the host you want to look up\&.
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIESS_SOCKET_FAMILY_IP4\fP Host supports only IP4 
.br
\fIESS_SOCKET_FAMILY_IP6\fP Host supports IP6 and IP4 
.br
\fI<0\fP Error\&. 
.RE
.PP

.SS "\fBess_socket_error_t\fP ess_socket_close (\fBess_socket_t\fP * socket)"

.PP
Close a socket\&. This function closes a socket\&.
.PP
\fBParameters:\fP
.RS 4
\fIsocket\fP the using socket struct
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIESS_SOCKET_ERROR_OK\fP Closed socket successfully 
.br
\fIESS_SOCKET_ERROR_NULL\fP socket was NULL 
.br
\fIESS_SOCKET_ERROR_CLOSE\fP Socket was already closed (other errors are very unlikely to occur) 
.RE
.PP

.SS "\fBess_socket_error_t\fP ess_socket_create (\fBess_socket_t\fP * socket, \fBess_socket_fam_t\fP fam, \fBess_socket_pro_t\fP protokoll, const char * addr, unsigned short port)"

.PP
setup the \fBess_socket\fP structure 
.PP
\fBParameters:\fP
.RS 4
\fIsocket\fP the ess_socket_t structure to fill
.br
\fIprotokoll\fP \fCESS_SOCKET_PROTO_STREAM\fP, \fCESS_SOCKET_PROTO_DRAM\fP or \fCESS_SOCKET_PROTO_DRAM_LITE\fP 
.br
\fIfam\fP Either \fCESS_SOCKET_FAMILY_IP4\fP, \fCESS_SOCKET_FAMILY_IP6\fP or \fCESS_SOCKET_FAMILY_BOTH\fP; latter means that the DNS resolver should decide\&. 
.br
\fIbind_addr\fP Address to bind to\&. If you want to bind to every address use '0\&.0\&.0\&.0' or '::' (IPv6 wildcard) 
.br
\fIport\fP The port to bind to\&.
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIESS_SOCKET_ERROR_OK\fP 
.RE
.PP

.SS "\fBess_socket_error_t\fP ess_socket_create_server (\fBess_socket_t\fP * socket)"

.PP
Create a TCP or UDP server socket\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsocket\fP the using socket struct 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIESS_SOCKET_ERROR_OK\fP the socket was created - TCP socket are listin 
.br
\fIESS_SOCKET_ERROR_UNSPEC\fP socket alwas created 
.br
\fIESS_SOCKET_ERROR_UNSPEC_PROTOKOL\fP unknown protokol  ESS_SOCKET_ERROR_UNSPEC_FAMILY unknown family 
.br
\fIESS_SOCKET_ERROR_GETADDR\fP 
.br
\fIESS_SOCKET_ERROR_BIND\fP error to call bind 
.br
\fIESS_SOCKET_ERROR_NULL\fP socket was NULL 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for OpenESS from the source code\&.
